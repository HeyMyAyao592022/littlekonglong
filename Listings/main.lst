C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\2023stuffs\Keil\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          #include "konglong.h"
   3          #include "lcd12864.h"
   4          #include "imgarr.h"
   5          // #include "seqqueue.h"
   6          
   7          sbit monitorLight = P3 ^ 3;
   8          
   9          /**
  10           * @brief 初始化定时器
  11           *
  12           */
  13          void initializeTimer();
  14          
  15          /**
  16           * @brief 检查小恐龙是否站在板子上
  17           *
  18           */
  19          void checkStandingBlock();
  20          
  21          /**
  22           * @brief 更新小恐龙 x 坐标
  23           *
  24           */
  25          void updataKonglongHorizonPos();
  26          
  27          /**
  28           * @brief 更新小恐龙 y 坐标
  29           *
  30           */
  31          void updataKonglongVerticalPos();
  32          
  33          /**
  34           * @brief 更新小板块坐标
  35           *
  36           */
  37          void updateBlockPos();
  38          
  39          /// @brief 游戏的状态
  40          data uint8 gameStatus = STATUS_RUNNING;
  41          data uint8 gameScores = 0;
  42          
  43          /// @brief 小恐龙
  44          data KongLong konglongBo = {KONGLONG_MIN_X, BLCOK_MAX_Y - 16, img_monster,
  45                        DIR_STILL, DIR_UP, DIR_LEFT, DEFUALT_STANDINGBLCOK};
  46          
  47          /// @brief 小板块
  48          data Block blocks[] = {
  49            {KONGLONG_MIN_X, BLCOK_MAX_Y},
  50            {30, BLCOK_MAX_Y + 31},
  51            {30, BLCOK_MAX_Y + 73},
  52            {80, BLCOK_MAX_Y + 117},
  53            {110, BLCOK_MAX_Y + 151}};
  54          
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 2   

  55          /// @brief 定时器计数
  56          data uint8 counter1 = 0;
  57          data uint8 counter2 = 0;
  58          
  59          /// @brief 定时器发出的信号，在主函数中相应
  60          data bit onUpdateKonglong1 = 0;
  61          data bit onUpdateKonglong2 = 0;
  62          data bit onUpdateBlock = 0;
  63          data bit onRedrawRoof = 0;
  64          // data bit onRedrawWall = 0;
  65          data bit onCheckStanding = 1;
  66          
  67          /// @brief 给小板块生成新的 x 坐标
  68          xdata uint8 blockHorizonPos[] = {30, 4, 45, 70, 110, 90};
  69          data uint8 currentHorizonPos = 0;
  70          #define BLOCK_HORIZON_POS_MAX 6
  71          
  72          void main(void)
  73          {
  74   1        // 遍历
  75   1        data uint8 i;
  76   1      
  77   1        // 按下 key1 开始
  78   1        while (1)
  79   1        {
  80   2          // 按 key1 开始
  81   2          if (!KeyIn1)
  82   2          {
  83   3            delay(10);
  84   3            break;
  85   3          }
  86   2        }
  87   1      
  88   1        // 初始化定时器
  89   1        initializeTimer();
  90   1      
  91   1        // 初始化屏幕
  92   1        LCD_init();
  93   1        delay(5);
  94   1      
  95   1        // 画顶部
  96   1        drawRoof();
  97   1        // drawWall();
  98   1      
  99   1        // 只要游戏还在运行中，那就不退出循环
 100   1        // game statues 为 0 则说明在运行中
 101   1        while (!gameStatus)
 102   1        {
 103   2          //  绘图
 104   2          if (konglongBo.standingBlock != -1)
 105   2          {
 106   3            drawBlock(blocks[konglongBo.standingBlock].x, blocks[konglongBo.standingBlock].y,
 107   3                  1);
 108   3          }
 109   2          drawKonglong(&konglongBo);
 110   2          for (i = 0; i < BLOCK_NUMBER; i++)
 111   2          {
 112   3            if ((i != (konglongBo.standingBlock)) && (blocks[i].y <= BLCOK_MAX_Y))
 113   3              drawBlock(blocks[i].x, blocks[i].y, blocks[i].y <= 7);
 114   3          }
 115   2      
 116   2          // scan key
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 3   

 117   2          if (!KeyIn1) // 向左
 118   2          {
 119   3            // 改变方向，则需要清除残影
 120   3            if (konglongBo.towards == DIR_RIGHT)
 121   3            {
 122   4              clearLine(konglongBo.x, konglongBo.y);
 123   4            }
 124   3            konglongBo.horizon_direction = DIR_LEFT;
 125   3            konglongBo.towards = DIR_LEFT;
 126   3          }
 127   2          else if (!KeyIn2) // 向右
 128   2          {
 129   3            // 改变方向，则需要清除残影
 130   3            if (konglongBo.towards == DIR_LEFT)
 131   3            {
 132   4              clearLine(konglongBo.x, konglongBo.y);
 133   4            }
 134   3            konglongBo.horizon_direction = DIR_RIGHT;
 135   3            konglongBo.towards = DIR_RIGHT;
 136   3          }
 137   2          else
 138   2            konglongBo.horizon_direction = DIR_STILL;
 139   2      
 140   2          if (onCheckStanding)
 141   2          {
 142   3            onCheckStanding = 0;
 143   3            checkStandingBlock();
 144   3          }
 145   2      
 146   2          if (onUpdateKonglong1)
 147   2          {
 148   3            onUpdateKonglong1 = 0;
 149   3            updataKonglongHorizonPos();
 150   3          }
 151   2      
 152   2          if (onUpdateKonglong2)
 153   2          {
 154   3            onUpdateKonglong2 = 0;
 155   3            updataKonglongVerticalPos();
 156   3          }
 157   2      
 158   2          if (onUpdateBlock)
 159   2          {
 160   3            onUpdateBlock = 0;
 161   3            updateBlockPos();
 162   3          }
 163   2      
 164   2          if (onRedrawRoof)
 165   2          {
 166   3            onRedrawRoof = 0;
 167   3            drawRoof();
 168   3          }
 169   2      
 170   2          // if (onRedrawWall)
 171   2          // {
 172   2          //  onRedrawWall = 0;
 173   2          //  drawWall();
 174   2          // }
 175   2        }
 176   1      
 177   1        // 若退出上面的循环，说明游戏结束，显示结果界面
 178   1        clear12864();
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 4   

 179   1      
 180   1        while (1)
 181   1        {
 182   2        }
 183   1      }
 184          
 185          /**
 186           * @brief 毫秒延迟
 187           *
 188           * @param n
 189           */
 190          void delay(uint8 n) // 延时ms级
 191          {
 192   1        data uint8 counter;
 193   1        while (n--)
 194   1        {
 195   2          counter = 110;
 196   2          while (--counter)
 197   2            ;
 198   2        }
 199   1      }
 200          
 201          /**
 202           * @brief 初始化定时器
 203           *
 204           */
 205          void initializeTimer()
 206          {
 207   1        TMOD = 0x11;        // 定时器0、1使用模式一
 208   1        TL0 = (65535 - 9216) % 256; // 10ms 中断一次
 209   1        TH0 = (65535 - 9216) / 256;
 210   1        TL1 = 0xff;
 211   1        TH1 = 0xff;
 212   1      
 213   1        TR0 = 1; // 定时器0 开始
 214   1        ET0 = 1; // 允许定时器0
 215   1        TR1 = 1;
 216   1        ET1 = 1;
 217   1      
 218   1        EA = 1;  // 允许定时
 219   1        PT0 = 1; // 优先级
 220   1      }
 221          
 222          /**
 223           * @brief 定时器 0
 224           *
 225           */
 226          void onTimer1() interrupt 1
 227          {
 228   1        // counter 用于计数
 229   1        ++counter1;
 230   1      
 231   1        // 定时器重新装初值
 232   1        TH0 = (65535 - 9216) / 256;
 233   1        TL0 = (65535 - 9216) % 256;
 234   1      
 235   1        // 每50ms
 236   1        if (!(counter1 % 5) && counter1)
 237   1        {
 238   2          onUpdateKonglong1 = 1;
 239   2        }
 240   1      
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 5   

 241   1        // 更新小恐龙垂直位移
 242   1        if (!(counter1 % 10) && counter1)
 243   1        {
 244   2          onUpdateKonglong2 = 1;
 245   2        }
 246   1      
 247   1        // 更新小板块的坐标
 248   1        if (!(counter1 % 10) && counter1)
 249   1        {
 250   2          onUpdateBlock = 1;
 251   2        }
 252   1      }
 253          
 254          /**
 255           * @brief 定时器 1
 256           *
 257           */
 258          void onTimer2() interrupt 3
 259          {
 260   1        if (!(counter2++ % 50) && counter2)
 261   1        {
 262   2          onRedrawRoof = 1;
 263   2        }
 264   1      }
 265          
 266          void checkStandingBlock()
 267          {
 268   1        data int8 standingFlag = -1;
 269   1        data uint8 diff;
 270   1        data uint8 i;
 271   1      
 272   1        // 如果小恐龙之前站在小板块上，则判断它是否离开了板块
 273   1        if (konglongBo.standingBlock != -1)
 274   1        {
 275   2          if ((konglongBo.y + 16) > blocks[konglongBo.standingBlock].y)
 276   2            diff = (konglongBo.y + 16) - blocks[konglongBo.standingBlock].y;
 277   2          else
 278   2            diff = blocks[konglongBo.standingBlock].y - (konglongBo.y + 16);
 279   2          if (diff <= 3 &&
 280   2            ((konglongBo.x + 10) >= blocks[konglongBo.standingBlock].x &&
 281   2             konglongBo.x <= (blocks[konglongBo.standingBlock].x + 15)))
 282   2          {
 283   3            // 如果小恐龙还站在那块板子上，就不需要重新检测了
 284   3            goto skipCheckStanding;
 285   3          }
 286   2          else
 287   2            // 如果小恐龙离开了那块板子，就需要重新检测
 288   2            goto checkStanding;
 289   2        }
 290   1        else
 291   1        {
 292   2        checkStanding:
 293   2          // 碰撞检测，判断小恐龙是否站在小板块上
 294   2          for (i = 0; i < BLOCK_NUMBER; i++)
 295   2          {
 296   3            if ((konglongBo.y + 16) > blocks[i].y)
 297   3              diff = (konglongBo.y + 16) - blocks[i].y;
 298   3            else
 299   3              diff = blocks[i].y - (konglongBo.y + 16);
 300   3            if (diff <= 3 &&
 301   3              (konglongBo.x + 10 >= blocks[i].x && konglongBo.x <= (blocks[i].x + 15)))
 302   3            {
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 6   

 303   4              konglongBo.vertical_direction = DIR_UP;
 304   4              // 让小恐龙的 y 坐标与板块保持一直
 305   4              konglongBo.y = blocks[i].y - 16;
 306   4              standingFlag = i;
 307   4              break;
 308   4            }
 309   3          }
 310   2          // 如果发现小恐龙没有站在任何小板块上，则让小恐龙一直下落
 311   2          konglongBo.standingBlock = standingFlag;
 312   2          if (konglongBo.standingBlock == -1)
 313   2          {
 314   3            konglongBo.vertical_direction = DIR_DOWN;
 315   3          }
 316   2        }
 317   1      skipCheckStanding:;
 318   1      }
 319          
 320          void updataKonglongHorizonPos()
 321          {
 322   1        //  更新小恐龙水平位移
 323   1        switch (konglongBo.horizon_direction)
 324   1        {
 325   2        case DIR_LEFT: // 向左
 326   2          if (konglongBo.x > KONGLONG_MIN_X)
 327   2          {
 328   3            --konglongBo.x;
 329   3            // 移动后需要检查是否站在小板块上面
 330   3            onCheckStanding = 1;
 331   3          }
 332   2          break;
 333   2        case DIR_RIGHT: // 向右
 334   2          if (konglongBo.x < 111)
 335   2          {
 336   3            ++konglongBo.x;
 337   3            // 移动后需要检查是否站在小板块上面
 338   3            onCheckStanding = 1;
 339   3          }
 340   2          break;
 341   2        default:
 342   2          break;
 343   2        }
 344   1      }
 345          
 346          void updataKonglongVerticalPos()
 347          {
 348   1        // 更新小恐龙垂直位移
 349   1        switch (konglongBo.vertical_direction)
 350   1        {
 351   2        case DIR_UP: // 向上
 352   2          if (konglongBo.standingBlock != -1)
 353   2          {
 354   3            konglongBo.y = blocks[konglongBo.standingBlock].y - 16;
 355   3            // 如果恐龙的 y 比 1 小，说明我们输了
 356   3            if (konglongBo.y < BLOCK_MIN_Y)
 357   3            {
 358   4              gameStatus = STATUS_LOSE;
 359   4            }
 360   3          }
 361   2          break;
 362   2        case DIR_DOWN: // 向下
 363   2          if (konglongBo.y < KONGLONG_MAX_Y)
 364   2          {
C51 COMPILER V9.60.7.0   MAIN                                                              06/16/2023 15:44:55 PAGE 7   

 365   3            ++konglongBo.y;
 366   3            // 移动后需要检查是否站在小板块上面
 367   3            onCheckStanding = 1;
 368   3          }
 369   2          else
 370   2            // 如果恐龙的 y 比 规定的y最大值 大，说明我们输了
 371   2            gameStatus = STATUS_LOSE;
 372   2          break;
 373   2        default:
 374   2          break;
 375   2        }
 376   1      }
 377          
 378          void updateBlockPos()
 379          {
 380   1        data uint8 i;
 381   1        for (i = 0; i < BLOCK_NUMBER; i++)
 382   1        {
 383   2          if (blocks[i].y > BLOCK_MIN_Y)
 384   2            --blocks[i].y;
 385   2          // 回收小板块
 386   2          else
 387   2          {
 388   3            clearObject(blocks[i].x, blocks[i].y);
 389   3            onRedrawRoof = 1;
 390   3            // 重置小板块的 y
 391   3            blocks[i].x = blockHorizonPos[(currentHorizonPos++) % BLOCK_HORIZON_POS_MAX];
 392   3            blocks[i].y = BLCOK_MAX_Y + 53;
 393   3          }
 394   2        }
 395   1        // 移动后需要检查是否站在小板块上面
 396   1        onCheckStanding = 1;
 397   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    815    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
